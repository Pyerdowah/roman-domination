\chapter{Badane algorytmy}

\section{Wprowadzenie}
Niniejszy rozdział opisuje algorytmy znajdujące funkcje dominujące rzymskie słabo spójne. Zostaną one przedstawione pod względem schematu działania, złożoności i wydajności, poprawności oraz podany ich pseudokod w języku angielskim, w celu zachowania czytelności. Lista analizowanych algorytmów jest następująca:

\begin{itemize}
    \item algorytm brute force - Brute Force,
    \item algorytm liniowy dla drzew - TreeLinear,
    \item algorytm programowania liniowego I - ILP,
    \item algorytm programowania liniowego II - ILP2,
    \item algorytm mrówkowy - AntColony,
    \item algorytm aproksymacyjny - Approx,
    \item algorytm zachłanny - Greedy.
\end{itemize}

Algorytmy wyznaczające WCRDF oraz optymalną $\gamma^{\text{wc}}_R(G)$ to: Brute Force, TreeLinear, ILP, ILP2. Będą one później zwane także algorytmami dokładnymi.

Algorytmy wyznaczające WCRDF, ale niekoniecznie optymalną $\gamma^{\text{wc}}_R(G)$ to: AntColony, Approx, Greedy. Będą one później zwane także algorytmami niedokładnymi, przybliżonymi, bądź heurystycznymi.

\section{Algorytm Brute Force}

   Poprawny algorytm Brute Force dla tego problemu nie został znaleziony wśród istniejących rozwiązań, dlatego został on zaprojektowany i zaimplementowany w ramach tej pracy.

\subsection{Działanie}
Jest to w zasadzie trywialna implementacja algorytmu wyznaczającego WCRDF poprzez sprawdzenie każdej kombinacji wartości \{0, 1, 2\} na wierzchołkach grafu wejściowego. Każda kombinacja sprawdzana jest pod względem poprawności według definicji słabo spójności w następujący sposób:
\begin{itemize}
    \item wyznaczany jest zbiór indukowany, który składa się ze zbioru dominującego (wierzchołki z wartościami \{1, 2\}) oraz sąsiadów wierzchołków zbioru dominującego,
    \item sprawdzenie, czy wszystkie wierzchołki z wartością 0 mają sąsiada z wartością 2,
    \item dla każdego wierzchołka ze zbioru indukowanego dodawane są krawędzie, ale tylko te wychodzące z wierzchołków zbioru dominującego
    \item następnie sprawdzenie, czy powstały graf jest spójny. Jeśli jest, to zbiór spełnia założenia definicji,
    \item ze wszystkich prawidłowych kombinacji wybierana jest ta o najmniejszej sumie wag WCRDF.
\end{itemize}

\subsection{Poprawność}
\label{subsec:bf_poprawnosc}

Poniżej przedstawiona zostanie analiza poprawności algorytmu BruteForce.  Algorytm sprawdza wszystkie możliwe kombinacje funkcji, gwarantując kompletność przeszukania oraz poprawność weryfikacji kombinacji względem definicji WCRDF.\\
\textbf{Kompletność przeszukania}\\
Algorytm generuje wszystkie możliwe przypisania wartości $f: V \to \{0,1,2\}$, co daje $3^n$ kombinacji, więc żadne potencjalne rozwiązanie nie będzie pominięte.\\
\textbf{Poprawność weryfikacji}\\
Dla każdej funkcji $f$, algorytm sprawdza:

\begin{itemize}
    \item warunek dominowania rzymskiego - sprawdzenie, czy wszystkie wierzchołki z wartością 0 mają sąsiada z wartością 2.
    
    \item warunek słabej spójności - wyznaczany jest podgraf indukowany, który składa się ze zbioru dominującego (wierzchołki z wartościami {1, 2}) oraz sąsiadów wierzchołków zbioru dominującego. Dla każdego wierzchołka ze zbioru indukowanego dodawane są krawędzie, ale tylko te wychodzące z wierzchołków zbioru dominującego. Sprawdzenie spójności tego podgrafu.
\end{itemize}
\textbf{Minimalność}\\
Spośród poprawnych kombinacji wartości WCRDF wybierana jest funkcja o najmniejszej sumie wag przypisanych do wierzchołków.\\

Zatem algorytm poprawnie wyznacza WCRDF oraz wartość $\gamma^{\text{wc}}_R(G)$.

\subsection{Złożoność i wydajność}

Algorytm ma złożoność wykładniczą, zatem nie będzie wykonywalny w rozsądnym czasie dla większych grafów, z uwagi na:
\begin{itemize}
    \item generowanie wszystkich kombinacji możliwych przypisań: $3^n$,
    \item sprawdzanie własności zbioru słabo spójnego dla każdego przypisania: $n^2$
\end{itemize}

Zatem złożoność czasowa algorytmu wynosi $O(3^n \cdot n^2)$\\
Złożoność pamięciowa ogranicza się do przechowywania grafu w pamięci i wynosi $O(n + m)$.

\subsection{Pseudokod}

\begin{algorithm}[H]
    \caption*{Algorytm Brute Force}
    \begin{algorithmic}[1]
        \Function{FindRomanDominatingSet}{graph}
            \State Initialize $min\_roman\_number \gets \infty$
            \State Initialize $best\_node\_values \gets None$
            \State $nodes \gets$ list of nodes in $graph$
    
            \For{each assignment of values ${0,1,2}$ to all nodes}
                \State $node\_values \gets$ mapping of nodes to values
                
                \For{each node in graph} \Comment{Sprawdzanie warunku dominowania}
                    \If{$node\_values[node] = 0$}
                        \If{\textbf{not} any neighbor of $node$ has value $2$}
                            \State \textbf{Continue} to next assignment
                        \EndIf
                    \EndIf
                \EndFor
                
                \State $induced\_set \gets$ nodes with values $\{1,2\}$
    
                \For{each node in $induced\_set$}
                    \State Add all its neighbors to $induced\_set$
                \EndFor
    
                \State Create empty $induced\_graph$
                \For{each node in $induced\_set$}
                    \If{$node\_values[node]$ is $1$ or $2$}
                        \For{each neighbor in $graph$}
                            \If{neighbor in $induced\_set$}
                                \State Add edge to $induced\_graph$
                            \EndIf
                        \EndFor
                    \EndIf
                \EndFor
    
                \If{$induced\_graph$ is connected}
                    \State Compute $roman\_number \gets$ sum of $node\_values$
                    \If{$roman\_number < min\_roman\_number$}
                        \State Update $min\_roman\_number$ and $best\_node\_values$
                    \EndIf
                \EndIf
            \EndFor
    
            \State \Return $(min\_roman\_number, best\_node\_values)$
        \EndFunction
    \end{algorithmic}
\end{algorithm}

\section{Algorytm liniowy dla drzew}

Algorytm ten został zaprojektowany i zaimplementowany we współpracy z promotorką.

\subsection{Działanie}

Dla każdego wierzchołka zdefiniowano następujące parametry:
\begin{itemize}
    \item $v['R']$ - wartość funkcji dominowania rzymskiego słabo spójnego w wierzchołku $v$, z założeniem, że $v['R']\in\{0,1,2\}$
    \item $v['n00']$ - oznacza liczbę dzieci z $R=0$ oraz bez sąsiada z $R=2$ (dziecko niezdominowane)
    \item $v['n01']$ - oznacza liczbę dzieci z $R=0$ i z sąsiadem z $R=2$ (dziecko zdominowane)
    \item $v['n1']$ - oznacza liczbę dzieci wierzchołka $v$ z $R = 1$
    \item $v['n2']$ - oznacza liczbę dzieci wierzchołka $v$ z $R = 2$
    \item $v['sw']$ - oznacza liczbę dzieci wierzchołka $v$ z $n00=1$ i $n01=0$. (wierzchołek wspierający, czyli taki, którego dziecko jest liściem)
    \item $v['ch'] =1$ jeśli $v['sw']>1$ lub jeśli $v['sw']=1$ i mający przynajmniej jedno dziecko z $R=0$; w przeciwnym razie $v['ch'] =0$. Jeśli $v['ch'] =1$, to $v['R']=2$ i w fazie 2 każde dziecko $v$ z $n00=1$ i z $n01=0$ dostaje $R=0$ i jego jedyne dziecko z $R=0$ zmienia wartość na $R=1$.
    \item $v['child']$ - jeśli $v$ jest wierzchołkiem wspierającym, wtedy wartość ta jest numerem liścia sąsiadującego z $v$.
\end{itemize}

Algorytm ma 2 fazy. W obu fazach rozpatrywane są wszystkie wierzchołki drzewa według odwrotnego porządku drzewa, czyli od ostatniego wierzchołka do korzenia (reverse tree-order). Wszystkie początkowo zdefiniowane wartości wynoszą 0. W bardzo ogólnym rozumieniu, rozpatrywany jest każdy wierzchołek na podstawie sąsiedztwa, relacji ojciec-dziecko oraz wartości zdefiniowanych parametrów i aktualizację ich w obu fazach. Wartości $R$ przy każdym wierzchołku, to wartości funkcji dominowania rzymskiego słabo spójnego.

Z racji sporego stopnia skomplikowania algorytmu, jego działanie zostanie przedstawione na przykładzie.
Dany jest graf $G$ będący drzewem ukorzenionym o 10 wierzchołkach, ponumerowanych wartościami od 0 do 9. Zakłada się, że wyznaczenie ojca każdego z wierzchołków jest trywialne, dlatego podczas rozważań wyznaczanie ojca wierzchołka będzie pomijane.

\begin{figure}[H]
    \centering
    \includegraphics[width=0.5\textwidth]{assets/image.png}
    \caption{Graf $G$ - przykładowe drzewo.}
    \label{fig:drzewo}
\end{figure}

\begin{enumerate}
    \item Jeśli wierzchołek jest liściem i nie jest korzeniem to następuje zwiększenie wartości 'n00' ojca o 1.\\
    Zatem dla liści 1,3,8,9, wartości ich ojców wyglądają następująco:\\
        T[7]['n00'] = 1  \\
        T[7]['child'] = 8  (od wierzchołka 8)\\
        T[4]['n00'] = 1 \\
        T[4]['child'] = 9  (od wierzchołka 9)\\
        T[2]['n00'] = 1  \\
        T[2]['child'] = 3  (od wierzchołka 3)\\
        T[0]['n00'] = 1 \\
        T[0]['child'] = 1  (od wierzchołka 1)
    \item Jeśli wierzchołek nie jest liściem:
    \begin{enumerate}
        \item Sprawdzenie czy wierzchołek posiada tylko jedno niezdominowane dziecko i posiada ojca. W tym przypadku ojciec będzie wierzchołkiem wspierającym. \\
        T[6]['sw'] = 1 (od wierzchołka 7)\\
        T[0]['sw'] = 2 (od wierzchołka 4 i 2)
        \item Sprawdzenie sumy wartości dzieci zdominowanych, niezdominowanych oraz liczby dzieci dla których wierzchołek jest wspierający. Jeśli ta suma jest większa od 1, to wartość tego wierzchołka ustawia się na 2, a parametr 'ch' na 1.\\
        T[0]['R'] = 2  (od wierzchołka 0)\\
        T[0]['ch'] = 1  (od wierzchołka 0)
        \begin{enumerate}
            \item Jeśli wierzchołek ma ojca to parametr 'n2' ojca zostaje zwiększony  o 1, a jeśli wierzchołek posiada tylko jedno niezdominowane dziecko, to zostaje zmniejszony parametr wspierający 'sw' u ojca.
        \end{enumerate}
        \item Jeśli wierzchołek nie jest wspierający:
            \begin{enumerate}
                \item Jeśli wierzchołek posiada niezdominowane dzieci lub jedno dziecko i żadnych dzieci z wartością 2 lub dzieci zdominowane, to wtedy wierzchołek będzie miał wartość 2. Dla istniejącego ojca wierzchołka zostaje zwiększony 'n2'.\\
                T[7]['R'] = 2  (od wierzchołka 7)\\
                T[6]['n2'] = 1  (od wierzchołka 7)\\
                T[4]['R'] = 2  (od wierzchołka 4)\\
                T[0]['n2'] = 2  (od wierzchołka 4 i 2)\\
                T[2]['R'] = 2  (od wierzchołka 2)\
                \item Jeśli wierzchołek posiada niezdominowane dziecko, to danemu wierzchołkowi przypisywana jest wartość 0, a temu dziecku wartość 1, a dla ojca zostaje zmniejszona wartość wspierania.
                \item Jeśli wierzchołek posiada tylko dzieci zdominowane, to danemu wierzchołkowi przypisywana jest wartość 1, a ojcu zostaje zwiększona wartość 'n1'.\\
                T[5]['R'] = 1  (od wierzchołka 5)\\
                T[4]['n1'] = 1  (od wierzchołka 5)
            \end{enumerate}
        \item Jeśli wartość wierzchołka wynosi 0, posiada on dzieci z wartością 2 oraz ojca, to zostaje zwiększona wartość ojca 'n01' o 1,\\
        T[5]['n01'] = 1  (od wierzchołka 6)
        \item Jeśli wartość wierzchołka wynosi 0, nie posiada on dzieci z wartością 2 oraz ojca, to zostaje zwiększona wartość ojca 'n00' o 1,\\
    \end{enumerate}
    \item Korzeń należy rozpatrzeć dodatkowo. Jeśli nie posiada on dzieci z wartościami 2 i sam ma wartość 0, to przypisuje się mu $R=2$,
    \item Jeśli liczba dzieci korzenia z $R=1$ jest równa liczbie dzieci pomniejszonej o 1, to korzeń również ma wartość 1.
\end{enumerate}

Zdjęcie przedstawia zachowanie algorytmu po fazie 1. Widać, że przypisanie nie jest jeszcze optymalne.

\begin{figure}[H]
    \centering
    \includegraphics[width=0.5\textwidth]{assets/phase1.png}
    \caption{Graf $G$ - po fazie 1. Wartości 0 to żółte wierzchołki, 1 - niebieskie, a 2 to czerwone.}
    \label{fig:drzewoFaza1}
\end{figure}

W fazie 2, dla każdego wierzchołka posiadającego ojca, tylko jedno dziecko niezdominowane i parametr ojca 'ch' wynoszący 1, wtedy należy ,,zmienić'' układ, poprzez ustawienie 0 na obecnym wierzchołku, ustawienie dziecka na 1 oraz zwiększenie liczby dzieci niedominowanych ojca wierzchołka. 
Ten warunek spełniony jest dla wierzchołków 4 i 2. Zatem:\\
T[4]['R'] = 0  (od wierzchołka 4)\\
T[9]['R'] = 1  (dziecko wierzchołka 4)\\
T[2]['R'] = 0  (od wierzchołka 2)\\
T[3]['R'] = 1  (dziecko wierzchołka 2)\\
T[0]['n00'] = 3  (ojciec wierzchołków 4 i 2)

Poniższy rysunek przedstawia prawidłowe, optymalne przypisanie wartości $R$ po fazie 2.\\

\begin{figure}[H]
    \centering
    \includegraphics[width=0.5\textwidth]{assets/phase2.png}
    \caption{Graf $G$ - po fazie 2 - finalna wersja. Wartości 0 to żółte wierzchołki, 1 - niebieskie, a 2 to czerwone.}
    \label{fig:drzewoFaza2}
\end{figure}

\subsection{Poprawność}

Poprawność algorytmu dla drzew zostanie wyznaczona poprzez szkic dowodu indukcyjnego. Dla każdego drzewa $T = (V, E)$ zakłada się, że algorytm liniowy poprawnie wyznacza funkcję $f : V \to \{0,1,2\}$ będącą WCRDF o najmniejszej wadze $\gamma_R^{\text{wc}}(T)$.\\
\textbf{Krok początkowy:}
\begin{itemize}
    \item Dla $|V| = 1, f(v)= 1 $, dominuje sam siebie. Algorytm wykrywa brak dzieci i przypisuje $R = 1$ zgodnie z warunkiem korzenia bez $n1$).
    \item Dla $|V| = 2$: liść otrzymuje $R = 0$, a korzeń $R = 2$, ponieważ nie ma innych dzieci dominujących. Sytuacja zostaje poprawnie wykryta na podstawie $n00 = 1$, $n01 = 0$, co daje przypisanie $R=2$ ojcu. 
\end{itemize}
\textbf{Krok indukcyjny:}\\ 
Zakłada się, że algorytm wyznacza poprawnie $\gamma_R^{\text{wc}}(T)$ dla wszystkich drzew o liczbie wierzchołków mniejszych od $n$. Należy wykazać, że działa również dla dowolnego drzewa $T$ o $|V| = n$.

Niech $r$ będzie korzeniem drzewa $T$, a $T_1, \dots, T_k$ jego poddrzewami o korzeniach $v_1, \dots, v_k$. Z założenia indukcyjnego dla każdego $T_i$ funkcja $f_i$ wyznaczona przez algorytm spełnia warunki WCRDF i jest najmniejsza na $T_i$.\\
\textbf{Spójność i dominowanie:}

Podczas przetwarzania $r$, algorytm zbiera informacje o:
\begin{itemize}
\item liczbie dzieci z $f=0$ i bez dominowania ($n00$),
\item liczbie dzieci wspierających ($sw$),
\item liczbie dzieci z $f=1$ i $f=2$.
\end{itemize}

W zależności od tych wartości:
\begin{itemize}
\item jeśli $n00 > 1$ lub jeśli posiada tylko jedno dziecko niezdominowane, a pozostałe dzieci mają $f = 0$ - $r$ przyjmuje $f(r) = 2$,
\item jeśli $n00 = 1$ i wspierające dziecko posiada jedno dziecko z $f=0$, to jego dziecko dostaje $f=1$ w Fazie~2,
\item jeśli wszystkie dzieci są już zdominowane, $r$ może przyjąć $f = 1$,
\item jeśli $r$ jest zdominowany przez któreś dziecko z $f = 2$ i jego dołączenie do zbioru nie jest konieczne do zapewnienia spójności, $r$ może przyjąć $f(r) = 0$.
\end{itemize}

W każdej z tych sytuacji:
\begin{itemize}
\item każde $v$ z $f(v)=0$ ma sąsiada z $f=2$,
\item zbiór $D = \{v : f(v) \in \{1,2\}\}$ jest słabo spójny, ponieważ każde $D_i$ jest spójne, a $r$ łączy je jako nadrzędny węzeł.
\end{itemize}
\textbf{Optymalność:}

Decyzje w algorytmie są podejmowane lokalnie optymalnie:
\begin{itemize}
\item przypisanie $f = 2$ tylko wtedy, gdy inne opcje (np. $f=1$ lub propagacja przez dzieci) nie wystarczają,
\item preferowanie struktury $[1,1]$ nad $[2,0]$ tam, gdzie jest to możliwe,
\item przypisania są zgodne z lokalną strukturą drzewa.
\end{itemize}

W związku z tym suma wag WCRDF jest najmniejsza możliwa przy spełnieniu warunków definicji, to kończy szkic dowodu.

\subsection{Złożoność i wydajność}
Algorytm ma złożoność liniową $O(n)$. W obu fazach rozpatrywane są wszystkie wierzchołki, od liści do korzenia. Uprzednio wyznaczana zostaje mapa ojcostwa, również liniowo. Algorytm zatem jest skalowalny i szybki dla większych grafów, natomiast ograniczony do jednej ich klasy - drzew.\\ Złożoność pamięciowa jest liniowa względem liczby wierzchołków, ze względu na przechowywanie drzewa w pamięci.

\subsection{Pseudokod}
\begin{algorithm}
    \caption*{Algorytm liniowy dla drzew - Faza 1}
    \begin{algorithmic}[1]
        \Function{Phase1}{T, root}
            \State $father\_map \gets$ Compute parent-child relationships using BFS
            \State $nodes\_ids \gets$ List of all nodes in $T$
    
            \For{each node $v$ in reversed($nodes\_ids$)}
                \State $father \gets father\_map[v]$
    
                \If{$v$ is a leaf and $v \neq root$}
                    \State Increase $T[father]['n00']$
                    \State Set $T[father]['child'] \gets v$
                \Else
                    \If{$T[v]['n00'] == 1$ and $T[v]['n01'] == 0$ and $father$ exists}
                        \State Increase $T[father]['sw']$
                    \EndIf
    
                    \If{$T[v]['sw'] + T[v]['n00'] + T[v]['n01'] > 1$}
                        \State Set $T[v]['R'] = 2$
                        \If{$father$ exists}
                            \State Increase $T[father]['n2']$
                            \If{$T[v]['n00'] == 1$ and $T[v]['n01'] == 0$}
                                \State Decrease $T[father]['sw']$
                            \EndIf
                        \EndIf
                        \State $T[v]['ch'] = 1$
                    \EndIf
    
                    \If{$T[v]['sw'] == 0$}
                        \If{$T[v]['n00'] > 1$ or ($T[v]['n00'] == 1$ and ($T[v]['n2'] == 0$ or $T[v]['n01'] > 0$))}
                            \State Set $T[v]['R'] = 2$
                            \If{$father$ exists}
                                \State Increase $T[father]['n2']$
                            \EndIf
                        \ElsIf{$T[v]['n00'] == 1$}
                            \State Set $T[v]['R'] = 0$
                            \State Set $T[T[v]['child']]['R'] = 1$
                            \If{$father$ exists}
                                \State Decrease $T[father]['sw']$
                            \EndIf
                        \EndIf
                        \If{$T[v]['n00'] == 0$ and $T[v]['n01'] > 0$}
                        \State Set $T[v]['R'] = 1$
                        \If{$father$ exists}
                            \State Increase $T[father]['n1']$
                        \EndIf
                    \EndIf
                    \EndIf
                    \If{$T[v]['R'] = 0$ \textbf{and} $T[v]['n2'] > 0$ \textbf{and} $father$ exists}
                        \State $T[father]['n01'] \gets T[father]['n01] + 1$
                    \EndIf

                    \If{$T[v]['R'] = 0$ \textbf{and} $T[v]['n2'] = 0$ \textbf{and} $father$ exists}
                        \State $T[father]['n00'] \gets T[father]['n00] + 1$
                    \EndIf

                \EndIf
            \EndFor
    
            \If{$T[root]['n2'] == 0$ and $T[root]['R'] == 0$}
                \State Set $T[root]['R'] = 2$
            \EndIf
            \If{$T[root]['n1'] ==$ (number of root's neighbors)}
                \State Set $T[root]['R'] = 1$
            \EndIf
    
            \State \Return $T$
        \EndFunction
    \end{algorithmic}
    \end{algorithm}
    
    \begin{algorithm}
    \caption*{Algorytm liniowy dla drzew - Faza 2}
    \begin{algorithmic}[1]
        \Function{Phase2}{T, root}
            \For{each node $v$ in reversed($nodes\_ids$)}
                \State $father \gets father\_map[v]$
                \If{$father$ exists}
                    \If{$T[v]['n00'] == 1$ and $T[father]['ch'] == 1$ and $T[v]['n01'] == 0$}
                        \State Set $T[v]['R'] = 0$
                        \State Set $T[T[v]['child']]['R'] = 1$
                        \State Increase $T[father]['n00']$
                    \EndIf
                \EndIf
            \EndFor
    
            \State \Return $T$
        \EndFunction
    \end{algorithmic}
\end{algorithm}

\FloatBarrier
\section{Algorytm programowania liniowego I}
Jest to algorytm programowania liniowego zaimplementowany na podstawie artykułu ,,Algorithmic complexity of weakly connected Roman domination in graphs'' \cite{ILP}.

\subsection{Działanie}

Dany jest $G'$ jako podgraf indukowany powstały z wierzchołków zbioru dominującego grafu $G$. Ten model programowania liniowego wymaga zdefiniowania następujących zmiennych:

\[
x_e =
\begin{cases}
1, & e \in E' \\
0, & e \notin E'
\end{cases}
\quad
y_e =
\begin{cases}
1, & e \in T' \\
0, & e \notin T'
\end{cases}
\]

\[
a_v =
\begin{cases}
1, & v \in V_1 \cup V_2 \\
0, & v \in V_0
\end{cases}
\quad
b_v =
\begin{cases}
1, & v \in V_2 \\
0, & v \in V_0 \cup V_1
\end{cases}
\]
gdzie \( v \in V \), \( e \in E \) i \( T' \) to drzewo rozpinające podgrafu \( G' \).

Zdefiniowano funkcję celu, czyli minimalizację wagi zbioru dominującego rzymskiego słabo spójnego:

\[
\text{Z: } \min \left( \sum_{v \in V} a_v + \sum_{v \in V} b_v \right)
\]
oraz ograniczenia:\\
Wierzchołek o wartości 0, bedzie miał co najmniej jednego sąsiada z wartością 2:
\[
    a_v + \sum_{k \in N_G(v)} b_k \geq 1, \quad v \in V, \tag{1}
\]
Krawędź istnieje w drzewie rozpinającym \( T' \), jeśli ta krawędź należy do \( G' \). Ograniczenie to zapewnia spójność w \( G' \):
\[
    y_e \leq x_e, \quad e \in E, \tag{2}
\]
Wybór krawędzi, które mają  wartość należącą do zbioru dominującego na przynajmniej jednym swoim końcu:
\[
    x_e \leq a_{i_e} + a_{j_e}, \quad e \in E_{G'}, \tag{3}
\]
Drzewo rozpinające \( T' \) ma liczbę krawędzi równą liczbie wierzchołków grafu pomniejszoną o 1:
\[
    \sum_{e \in E} y_e = n - 1, \tag{4}
\]
Drzewo rozpinające \( T' \) nie posiada cykli:
\[
    \sum_{i_e, j_e \in S} y_e \leq |S| - 1, \quad S \subseteq V, \quad |S| \geq 3, \tag{5}
\]
Podzbiór wierzchołków z $b_v = 1$, czyli $(V_2)$, jest podzbiorem wierzchołków z $a_v = 1$, czyli $(V_1 \cup V_2)$
\[
    b_v \leq a_v, \quad v \in V. \tag{6}
\]

Warunki 1, 2, 5 gwarantują, że \( T' \) jest drzewem rozpinającym grafu \( G' \).

\subsection{Poprawność}

Poniżej przedstawiona zostaje analiza, dlaczego model programowania liniowego I opisany powyżej poprawnie odwzorowuje problem wyznaczania WCRDF, a jego rozwiązanie minimalizuje wartość $\gamma_R^{\text{wc}}(G)$.\\
\textbf{Każde dopuszczone rozwiązanie modelu ILP jest poprawną funkcją WCRDF.}

Rozważane jest dowolne przypisanie zmiennych $a_v, b_v, x_e, y_e$ spełniające ograniczenia (1)-(6).

\begin{itemize}
    \item Ograniczenie (1): dla każdego $v$ z $a_v = 0$ (czyli $f(v) = 0$), istnieje co najmniej jeden sąsiad $k$ z $b_k = 1$ (czyli $f(k) = 2$). To spełnia warunek dominowania rzymskiego.
    
    \item Ograniczenia (2)-(5): definiują graf $G'$ (na podstawie $x_e$), oraz jego drzewo rozpinające $T'$ (na podstawie $y_e$). W szczególności:
    \begin{itemize}
        \item (2): $T'$ zawiera się w $G'$,
        \item (3): każda krawędź $x_e$ łączy dwa wierzchołki z przynajmniej jednym $a = 1$,
        \item (4)-(5): $T'$ ma $n-1$ krawędzi i nie zawiera cykli, czyli jest drzewem,
    \end{itemize}
    \item Zatem $T'$ rozciąga się na zbiorze $D = \{v : a_v = 1\}$ i łączy go w sposób spójny - spełnia to warunek słabej spójności.
    
    \item Ograniczenie (6): każdy wierzchołek z $b_v = 1$ (czyli $f(v) = 2$) musi mieć również $a_v = 1$ - co odwzorowuje relację $V_2 \subseteq V_1 \cup V_2$.
\end{itemize}
\textbf{Każda poprawna funkcja WCRDF może być zakodowana jako przypisanie zmiennych.}

Dla dowolnej funkcji $f : V \to \{0,1,2\}$ spełniającej definicję WCRDF, można przypisać:
\[
a_v = \begin{cases}
1 & \text{jeśli } f(v) > 0 \\
0 & \text{jeśli } f(v) = 0
\end{cases}
\quad
b_v = \begin{cases}
1 & \text{jeśli } f(v) = 2 \\
0 & \text{jeśli } f(v) \ne 2
\end{cases}
\]

Podgraf $G'$ indukowany przez wierzchołki z $a_v = 1$ jest spójny (bo $f$ spełnia definicję WCRDF), więc istnieje drzewo rozpinające $T'$ - można przypisać $x_e$ i $y_e$ tak, by spełnić wszystkie ograniczenia (2)-(5).\\
\textbf{Funkcja celu odwzorowuje wagę funkcji $f$}

Wartość funkcji celu to:
\[
\sum_{v \in V} a_v + \sum_{v \in V} b_v = |\{v : f(v) \in \{1,2\}\}| + |\{v : f(v) = 2\}|
= \sum_{v} f(v)
\]

Zatem minimalizacja funkcji celu odpowiada minimalizacji wagi funkcji WCRDF.

\subsection{Złożoność i wydajność}

Liczba zmiennych dla grafu o $n$ wierzchołkach i $m$ krawędziach wynosi $O(n+m)$.

\begin{enumerate}
    \item Dominowanie rzymskie: jedno na każdy wierzchołek, zatem $n$ ograniczeń.   
    \item Zależność między \( y_e \) a \( x_e \): jedno na każdą krawędź, zatem $m$ ograniczeń.    
    \item Ograniczenie dostępu tylko wśród chronionych wierzchołków: jedno na każdą krawędź, zatem $m$ ograniczeń.    
    \item Liczba krawędzi w drzewie rozpinającym: jedno globalne ograniczenie.  
    \item Brak cykli (ograniczenia cykliczne): jedno dla każdego podzbioru \( S \subseteq V \), gdzie \( |S| \geq 3 \). W najgorszym przypadku liczba tych podzbiorów rośnie wykładniczo: $O(2^n)$.  
    \item Relacja \( b_v \leq a_v \): jedno na każdy wierzchołek, zatem $n$ ograniczeń.
\end{enumerate}

Zatem w najgorszym przypadku liczba ograniczeń wynosi $	O(n+m+2^n)$.
Złożoność czasowa jest wykładnicza w liczbie zmiennych. Ze względu na ograniczenia cykliczne trudność rozwiązywania jest niestabilna.\\
Złożoność pamięciowa również w najgorszym przypadku jest wykładnicza ze względu na przechowywanie zmiennych i ograniczeń.

\subsection{Pseudokod}

\begin{algorithm}
    \caption*{Algorytm programowania liniowego I}
    \begin{algorithmic}[1]
        \Function{ILP}{graph}
            \State $V \gets$ list of nodes in $graph$
            \State $E \gets$ list of edges in $graph$
    
            \State Initialize ILP model $model$
            \State Set objective: Minimize $\sum (a[i] + b[i])$ for all nodes $i \in V$
    
            \State Define binary variables:

            \State $x[i, j]$ for $(i, j) \in E$ \Comment{1 jeśli krawędź jest w $G'$}
            \State $y[i, j]$ for $(i, j) \in E$ \Comment{1 jeśli krawędź jest w drzewie rozpinającym $T'$}
            \State $a[i]$ for $i \in V$ \Comment{1 jeśli wierzchołek należy do $V_1 \cup V_2$}
            \State $b[i]$ for $i \in V$ \Comment{1 jeśli wierzchołek należy do $V_2$}
    
            \State \textbf{Constraints:}
    
            \For{each node $i$ in $V$} \Comment{Każdy wierzchołek musi być chroniony}
                \State Add constraint: $a[i] + \sum b[k] \geq 1$, where $k$ are neighbors of $i$
            \EndFor
    
            \For{each edge $(i, j)$ in $E$}
                \State Add constraint: $y[i, j] \leq x[i, j]$ \Comment{Krawędź drzewa musi istnieć w $G'$}
                \State Add constraint: $x[i, j] \leq a[i] + a[j]$ \Comment{Krawędzie drzewa muszą łączyć chronione wierzchołki}
            \EndFor
    
            \State Add constraint: $\sum y[i, j] = |V| - 1$ \Comment{Drzewo musi mieć $|V| - 1$ krawędzi}
    
            \State Find cliques of size $\geq 3$ in $graph$ and store as $subsets$
            \For{each subset $S$ in $subsets$} \Comment{Eliminacja cykli}
                \State Add constraint: $\sum y[i, j] \leq |S| - 1$ for edges $(i, j) \in S$
            \EndFor
    
            \For{each node $i$ in $V$} \Comment{Wierzchołki z $V_2$ muszą należeć do $V_1 \cup V_2$}
                \State Add constraint: $b[i] \leq a[i]$
            \EndFor
    
            \State Solve ILP model
    
            \State Extract solution:
            \For{each node $i$ in $V$}
                \State $solution[i] \gets round(a[i].X) + 2 * round(b[i].X)$
            \EndFor
    
            \State \Return $(model.objVal, solution)$
        \EndFunction
    \end{algorithmic}
\end{algorithm}

\FloatBarrier
\section{Algorytm programowania liniowego II}
Jest to algorytm programowania liniowego zaimplementowany na podstawie artykułu ,,Algorithmic complexity of weakly connected Roman domination in graphs'' \cite{ILP}, podobnie jak poprzedni.
\subsection{Działanie}
Model ten opiera się na przepływach. W tym modelu rozpatrywany jest graf jako wierzchołek, który zużywa jednostkę przepływu, przepływając przez krawędzie grafu. Na wejściu definiowany jest zewnętrzny przepływ, którego liczba jednostek jest równa liczbie wierzchołków grafu. Zachowana jest zasada przepływu sieci, dlatego trzeba wprowadzić przepływ zewnętrzny w jak największej ilości przez pojedynczy wierzchołek.\\
Należy zdefiniować następujące zmienne:
\[
x_i =
\begin{cases}
1, & i \in V_1 \cup V_2 \\
0, & i \in V_0
\end{cases}
\quad
y_i =
\begin{cases}
1, & i \in V_2 \\
0, & i \in V_0 \cup V_1
\end{cases}
\]

\[
a_e =
\begin{cases}
1, & e \in E' \\
0, & e \notin E'
\end{cases}
\quad
t_i =
\begin{cases}
1, & \text{wierzchołek korzenia} = i \\
0, & \text{pozostałe wierzchołki}
\end{cases}
\]

\[
u_i \in N \cup \{0\}, \quad v_e \in [-n, n].
\]
gdzie:\\
$t_i$ zdefiniowany dla każdego wierzchołka grafu. Identyfikuje, gdzie zewnętrzny wierzchołek jest traktowany jako wejście. \\
$u_i$ reprezentuje liczbę jednostek przepływu zewnętrznego dla danego wierzchołka grafu.\\
$v_e$ oznacza jednostki przepływające przez dane krawędzie.\\
$a_e$ oznacza przynależność krawędzi do podgrafu indukowanego.\\
$x_i, y_i$ oznaczają przynależność do zbioru dominującego rzymskiego słabo spójnego.

Minimalizującą liczbę dominowania rzymskiego słabo spójnego jako funkcję celu należy zdefiniować następująco:

\[
\text{Z: } \min \left( \sum_{i \in V} x_i + \sum_{i \in V} y_i \right)
\]
mając dane ograniczenia:\\
Wierzchołek z wartością 0 sąsiaduje z przynajmniej jednym wierzchołkiem z wartością 2:
\[
x_i + \sum_{j \in N_G(i)} y_j \geq 1, \quad i \in V \tag{1}
\]
Ograniczenie zmiennych $x$ i $y$, aby były zgodne ze zdefiniowaną przynależnością:
\[
y_i \leq x_i, \quad i \in V \tag{2}
\]
Krawędź $e \in E'$ ma przynajmniej jeden koniec z wierzchołkiem o wartości przynajmniej 1 (należącym do zbioru dominującego):
\[
a_e \leq x_{i_e} + x_{j_e}, \quad e \in E \tag{3}
\]
Jest tylko jeden wierzchołek w grafie $G'$, gdzie jest dostarczony przepływ zewnętrzny:
\[
\sum_{i \in V} t_i = 1 \tag{4}
\]
Wielkość przepływu co najwyżej $n$:
\[
u_i \leq n \cdot t_i, \quad i \in V \tag{5}
\]
Przepływ ma miejsce tylko w krawędziach należących do $E'$:
\[
v_e \leq n \cdot a_e, \quad e \in E \tag{6}
\]

\[
v_e \geq -n \cdot a_e, \quad e \in E \tag{7}
\]
Reprezentacja zasady zachowania sieci:
\[
u_i + \sum_{e: j_e = i} v_e - \sum_{e: i_e = i} v_e = 1, \quad i \in V \tag{8}
\]
Każdy wierzchołek $v \in V$ musi mieć przynajmniej jeden ustalony wierzchołek w $E'$
\[
a_e \geq 1, \quad e \in E \tag{9}
\]

\subsection{Poprawność}

Poniżej przedstawiona zostaje analiza, dlaczego model programowania liniowego II opisany
powyżej poprawnie odwzorowuje problem wyznaczania WCRDF, a jego rozwiązanie minimalizuje
wartość $\gamma_R^{\text{wc}}(G)$.

\textbf{Poprawność odwzorowania funkcji WCRDF.}

Zmiennym w modelu odpowiadają następujące interpretacje:
\begin{itemize}
    \item $x_i = 1 \iff f(i) \in \{1,2\}$,
    \item $y_i = 1 \iff f(i) = 2$,
    \item $a_e = 1 \iff$ krawędź $e$ należy do grafu $G'$ indukowanego przez zbiór dominujący,
    \item $t_i = 1 \iff$ wierzchołek $i$ to „źródło” przepływu,
    \item $u_i$ - liczba jednostek przepływu wchodząca do wierzchołka $i$,
    \item $v_e$ - przepływ przez krawędź $e$.
\end{itemize}

Warunek dominowania rzymskiego zapewnia ograniczenie (1), bo jeżeli \( x_i = 0 \) (\( f(i) = 0 \)), to musi istnieć sąsiad \( j \) z \( y_j = 1 \), czyli \( f(j) = 2 \).:

\[
x_i + \sum_{j \in N(i)} y_j \geq 1
\]

Warunek \( y_i \leq x_i \) (ograniczenie (2)) zapewnia, że zgodnie z definicją, że wierzchołek z \( f(i) = 2 \) należy także do zbioru z \( f(i) \geq 1 \).

Warunek łączności: zbiór \( D = \{i : x_i = 1\} \) musi tworzyć spójny podgraf \( G' \), którego spójność jest zapewniona przez:

\begin{itemize}
    \item ograniczenia (3), (6), (7): krawędzie przepływu są ograniczone do tych z końcami w \( D \),
    \item ograniczenia (4), (5), (8): modeluje się jednostkowy przepływ z jednego wierzchołka źródłowego ($t_i = 1$) przez cały zbiór \( D \),
    \item ograniczenie (8): zasada zachowania przepływu - każdy wierzchołek „zużywa” jedną jednostkę, więc przepływ musi dotrzeć do każdego z nich,
    \item ograniczenie (9): każdy wierzchołek musi być incydentny z co najmniej jedną krawędzią $a_e$, czyli nie być odizolowany.
\end{itemize}

Zatem cała struktura odpowiada spójnemu podgrafowi \( G' \).

\textbf{Odwzorowanie każdej funkcji WCRDF.}

Dla każdej poprawnej funkcji WCRDF \( f : V \to \{0,1,2\} \) można ustawić zmienne:

\[
x_i =
\begin{cases}
1, & \text{jeśli } f(i) > 0 \\
0, & \text{jeśli } f(i) \leq 0
\end{cases}
\quad
y_i =
\begin{cases}
1, & \text{jeśli } f(i) = 2 \\
0, & \text{jeśli } f(i) \ne 2 
\end{cases}
\]

Zbiór \( D = \{i : x_i = 1\} \) indukuje spójny graf \( G' \), więc można wybrać \( a_e \) dla jego krawędzi i zdefiniować przepływ \( v_e \), \( u_i \) zgodnie ze standardową metodą budowania drzew przepływu. Wybierając dowolny wierzchołek z \( f = 2 \) jako korzeń ($t_i = 1$), zostają spełnione wszystkie ograniczenia.

\textbf{Minimalizacja funkcji celu.}

Funkcja celu:
\[
\min \left( \sum x_i + \sum y_i \right) = \sum_{i : f(i) = 1} 1 + \sum_{i : f(i) = 2} 2 = \sum f(i)
\]
odpowiada dokładnie wadze funkcji \( f \). Minimalizacja celu odpowiada wyznaczeniu \( \gamma^{\text{wc}}_R(G) \).

\subsection{Złożoność i wydajność}

Suma zmiennych w sformułowanym modelu wynosi $3n + m$, będących wartościami logicznymi, $n$ całkowitych i $m$ ciągłych.
\begin{itemize}
    \item Pokrycie i relacje \( x,y \) - ograniczenia zapewniające, że każdy wierzchołek jest zdominowany oraz że jeśli \( y_i = 1 \), to \( x_i = 1 \). Dają łącznie \( n + n = 2n \) ograniczeń.
    
    \item Krawędziowe ograniczenia - dotyczące relacji między zmiennymi \( a_e \) i \( x_i \), oraz ograniczające wartości przepływu \( v_e \) przez krawędzie. Są to ograniczenia (3), (6) i (7), po jednym na każdą krawędź, co daje łącznie $3m$ ograniczeń.
    
    \item Struktura drzewa przepływu obejmuje:
    \begin{itemize}
        \item jedno ograniczenie wymuszające dokładnie jeden korzeń przepływu\\ (warunek \( \sum t_i = 1 \)),
        \item \( n \) ograniczeń ograniczających wartość \( u_i \) (jednostki przepływu) do \( n \cdot t_i \),
        \item \( n \) równań przepływu dla każdego wierzchołka (bilans: wejście + wyjście = 1),
    \end{itemize}
    co łącznie daje 2n + 1 ograniczeń.
    
    \item Wymuszenie incydencji - ograniczenie (9) wymusza, by każdy wierzchołek miał co najmniej jedną krawędź w \( E' \) (grafie dominującym). Daje to dodatkowe $n$ ograniczeń.
\end{itemize}

\noindent
Liczba ograniczeń wynosi $7n+3m+2$. Wynika to z tego, że nie wszystkie ograniczenia to są nierówności.
Złożoność pamięciowa wynosi $O(n+m)$.\\
W najgorszym przypadku złożoność czasowa będzie wykładnicza w $n$. Trudność rozwiązywania jest złożona przez przepływy, ale bardziej stabilna, niż w algorytmie ILP, który ze względu na dużą liczbe cykli może znacznie wydłużyć swój czas działania.

\subsection{Pseudokod}
\begin{algorithm}
    \caption*{Algorytm programowania liniowego II}
    \begin{algorithmic}[1]
        \Function{ILP\_II}{graph}
            \State Initialize ILP model $model$ with minimization objective
    
            \State $V \gets$ list of nodes in $graph$
            \State $E \gets$ list of edges in $graph$
            \State $n \gets |V|$ \Comment{Liczba wierzchołków}
    
            \State Define binary variables:

            \State $x[i]$ for $i \in V$ \Comment{1 jeśli wierzchołek $i$ należy do zbioru $X$}
            \State $y[i]$ for $i \in V$ \Comment{1 jeśli wierzchołek $i$ należy do zbioru $Y$}
            \State $a[e]$ for $e \in E$ \Comment{1 jeśli krawędź $e$ należy do drzewa rozpinającego}
            \State $t[i]$ for $i \in V$ \Comment{1 jeśli wierzchołek $i$ jest korzeniem}

    
            \State Define integer and continuous variables:

            \State $u[i]$ for $i \in V$ \Comment{Zmienna całkowita do struktury drzewa}
            \State $v[e]$ for $e \in E$ \Comment{Zmienna przepływu z ograniczeniami $[-n, n]$}


            \State \textbf{Objective:}
            \State Minimize $\sum (x[i] + y[i])$ for all $i \in V$
    
            \State \textbf{Constraints:}
    
            \For{each node $i$ in $V$} \Comment{Zapewnij pokrycie wszystkich wierzchołków}
                \State Add constraint: $x[i] + \sum y[j] \geq 1$, where $(i,j) \in E$
                \State Add constraint: $y[i] \leq x[i]$
                \State Add constraint: $\sum a[e] \geq 1$, where $e$ contains $i$
            \EndFor
    
            \For{each edge $e = (i_e, j_e)$ in $E$}
                \State Add constraint: $a[e] \leq x[i_e] + x[j_e]$
                \State Add constraint: $v[e] \leq n \cdot a[e]$
                \State Add constraint: $v[e] \geq -n \cdot a[e]$
            \EndFor
    
            \State Add constraint: $\sum t[i] = 1$ \Comment{Tylko jeden korzeń istnieje}
    
            \For{each node $i$ in $V$} \Comment{Ograniczenia struktury drzewa}
                \State Add constraint: $u[i] \leq n \cdot t[i]$
                \State Add constraint: $u[i] + \sum v[e] - \sum v[e] = 1$, for edges $e$ entering/exiting $i$
            \EndFor
    
            \State Solve ILP model
    
            \State Extract solution:
            \For{each node $i$ in $V$}
                \State $solution[i] \gets round(x[i].varValue) + 2 \times round(y[i].varValue)$
            \EndFor
    
            \State \Return $(model.objVal, solution)$
        \EndFunction
    \end{algorithmic}
    \end{algorithm}

\FloatBarrier
\section{Algorytm mrówkowy}

Algorytm ten został zaimplementowany w ramach tej pracy, w oparciu o znaną powszechnie konstrukcję algorytmu mrówkowego.

\subsection{Działanie}
Należy zdefiniować następujące zmienne i heurystyki:
\begin{itemize}
    \item num\_ants - liczba mrówek w każdej iteracji.
    \item num\_iterations - liczba iteracji algorytmu.
    \item \textbf{\rho} - współczynnik parowania feromonów, określający, jak szybko feromony zanikają.
    \item $\tau_{init}$ - początkowa wartość feromonów na wszystkich krawędziach.
    \item \textbf{\alpha} - wpływ poziomu feromonów na decyzję wyboru ścieżki.
    \item \textbf{\beta} - wpływ heurystyki lokalnej (tutaj liczba sąsiadów wierzchołka) na decyzję wyboru ścieżki.
\end{itemize}
Na początku należy zainicjować feromony na każdej krawędzi wejściowego grafu.\\
Dla zdefiniowanej liczby iteracji algorytmu, a następnie dla każdej mrówki:
\begin{enumerate}
    \item na podstawie heurystyk, parametrów, sąsiadów wierzchołków i feromonów budowane jest rozwiązanie dla pojedynczej mrówki w postaci prawdopodobieństw wartości na wierzchołkach grafu.\\
    Każdy wierzchołek \( i \) przyjmuje wartość \( v \in \{0,1,2\} \) z prawdopodobieństwem:

\[
P_i(v) = \frac{ \left( \sum\limits_{j \in N(i)} \tau_{ij} \right)^\alpha \cdot (\eta_i)^\beta }
{\sum\limits_{v' \in \{0,1,2\}} \left( \sum\limits_{j \in N(i)} \tau_{ij} \right)^\alpha \cdot (\eta_i)^\beta}
\]

gdzie:\\
- \( \tau_{ij} \) to poziom feromonów na krawędzi \( (i,j) \),\\
- \( \eta_i = |N(i)| \) to liczba sąsiadów wierzchołka \( i \) będąca heurystyką

    \item rozwiązanie sprawdzane jest pod katem poprawności względem definicji. Sprawdzane jest, czy wierzchołki z wartościami 0 posiadają sąsiada z wartościami 2 oraz warunek słabo spójności. Jeśli warunek nie jest spełniony, rozwiązanie otrzymuje nieskończoną wartość wagi, co sprawia, że nie jest brane pod uwagę w rozwiązaniu. W przeciwnym razie wartości na wierzchołkach grafu są sumowane.
\end{enumerate}
Po przejściu wszystkich mrówek, uaktualniane są wartości feromonów na grafie, zmniejszając ich wartość o współczynnik ewaporacji oraz aktualizację wartości feromonów na podstawie najlepszego dotychczasowego rozwiązania.

\[
\tau_{ij} = (1 - \rho) \cdot \tau_{ij} + \Delta \tau_{ij}
\]

gdzie:\\
- \( \rho \) to współczynnik parowania feromonów,\\
- \( \Delta \tau_{ij} \) to ilość feromonów dodana w oparciu o najlepsze rozwiązanie:

\[
\Delta \tau_{ij} = \frac{1}{f(best\_solution^*)}
\]

gdzie \( best\_solution^* \) to najlepsze znalezione rozwiązanie, a \( f(best\_solution^*) \) to suma wartości wierzchołków grafu najlepszego rozwiązania.

\subsection{Poprawność}
Algorytm mrówkowy, choć dąży do najmniejszej wartości sumy wag WCRDF, to nie zakłada, że znalezione zostanie $\gamma^{\text{wc}}_R(G)$, dlatego sprawdzana jest wyłącznie poprawność słabo spójności. Dzieje się to w sposób analogiczny jak w algorytmie Brute Force, co zostało pokazane w punkcie \ref{subsec:bf_poprawnosc}.

\subsection{Złożoność i wydajność}

Algorytm działa przez $num\_iterations$ iteracji i dla każdej mrówki $num\_ants$. Budowanie rozwiązania wykonuje się w czasie $O(n)$, sprawdzenie rozwiązania w czasie $O(n^2)$.
Zatem złożoność wynosi $O(num\_iterations \cdot num\_ants \cdot n^2)$, co sprawia, że algorytm dla większych grafów może być kosztowny obliczeniowo.\\
W pamięci przechowywane są feromony $O(m)$ oraz rozwiązania $O(num\_ants \cdot n)$, więc
złożoność pamięciowa wynosi $O(m+num\_ants \cdot n)$.

\subsection{Pseudokod}
\begin{algorithm}
    \caption*{Algorytm mrówkowy - inicjalizacja}
    \begin{algorithmic}[1]
    
    \Function{InitializePheromones}{graph}
        \State $pheromones \gets$ Assign initial pheromone value to all edges
        \State \Return $pheromones$
    \EndFunction

    \Function{ChooseNodeValue}{node, pheromones, neighbors}
        \State $values \gets \{0, 1, 2\}$
        \State Initialize $probabilities$ as empty list

        \For{each $value$ in $\{0, 1, 2\}$}
            \State Compute $pheromone\_level$ as sum of pheromones of neighboring edges
            \State Compute probability as $(pheromone\_level^\alpha) \times (heuristic^\beta)$
            \State Append probability to $probabilities$
        \EndFor

        \State Normalize probabilities
        \State \Return Random weighted choice from $\{0, 1, 2\}$
    \EndFunction

    \Function{BuildSolution}{graph, pheromones}
        \State Initialize $node\_values$ as empty dictionary
        \For{each node in graph}
            \State $neighbors \gets$ list of node's neighbors
            \State Assign $node\_values[node] \gets$ \Call{ChooseNodeValue}{node, pheromones, neighbors}
        \EndFor
        \State \Return $node\_values$
    \EndFunction

    \Function{IsValidRomanDominatingSet}{graph, node\_values}
        \For{each node in graph}
            \If{$node\_values[node] = 0$ and no neighbor has value $2$}
                \State \Return False
            \EndIf
        \EndFor

        \State $induced\_set \gets$ nodes with values $\{1, 2\}$
        \For{each node in $induced\_set$}
            \State Add all neighbors to $induced\_set$
        \EndFor

        \State Create empty graph $induced\_graph$
        \For{each node in $induced\_set$}
            \If{$node\_values[node] \in \{1, 2\}$}
                \For{each neighbor in graph}
                    \If{neighbor in $induced\_set$}
                        \State Add edge between node and neighbor in $induced\_graph$
                    \EndIf
                \EndFor
            \EndIf
        \EndFor

        \If{$induced\_graph$ is not connected}
            \State \Return False
        \EndIf
        \State \Return True
    \EndFunction
    
    \end{algorithmic}
\end{algorithm}

\begin{algorithm}
    \caption*{Algorytm mrówkowy - główna petla}
    \begin{algorithmic}[1]
    
        \Function{UpdatePheromones}{graph, pheromones, solutions}
        \For{each edge in pheromones}
            \State Reduce pheromone level using evaporation rate
        \EndFor

        \State $best\_solution \gets$ Solution with minimum Roman number
        \For{each node in $best\_solution$}
            \For{each neighbor of node}
                \State Increase pheromone level on edge $(node, neighbor)$
            \EndFor
        \EndFor
    \EndFunction

    \Function{Execute}{graph}
        \State $pheromones \gets$ \Call{InitializePheromones}{graph}
        \State $best\_solution \gets None$
        \State $best\_roman\_number \gets \infty$

        \For{each iteration in num\_iterations}
            \State Initialize $solutions$ as empty list

            \For{each ant in num\_ants}
                \State $solution \gets$ \Call{BuildSolution}{graph, pheromones}
                \State $roman\_number \gets$ \Call{EvaluateSolution}{graph, solution}
                \State Append $(solution, roman\_number)$ to $solutions$

                \If{$roman\_number < best\_roman\_number$}
                    \State Update $best\_roman\_number$ and $best\_solution$
                \EndIf
            \EndFor

            \State \Call{UpdatePheromones}{graph, pheromones, solutions}
        \EndFor

        \State \Return $(best\_roman\_number, best\_solution)$
    \EndFunction
    
    \end{algorithmic}
\end{algorithm}

\FloatBarrier
\section{Algorytm aproksymacyjny}

Algorytm ten został zaimplementowany na podstawie artykułu \cite{ILP}.

\subsection{Działanie}

 W artykule zdefiniowano następujące kroki algorytmu:
\begin{enumerate}
    \item Wyznaczenie zbioru dominującego spełniającego warunki zbioru dominującego spójnego CDS.
    \item Dla wierzchołków ze zbioru dominującego przypisywana jest wartość 2, dla pozostałych wierzchołków przypisywana jest wartość 0.
\end{enumerate}

Udowodniono, że takie rozwiązanie jest aproksymacyjne, o współczynniku aproksymacji równym
$2(1+\epsilon)(1 + \ln(\Delta - 1))$, gdzie $\epsilon$ to współczynnik dokładności aproksymacji, a $\Delta$ to maksymalny stopień wierzchołka w grafie. Aby móc przetestować w pełni działanie algorytmu, zaimplementowano go w całości, na podstawie sugestii obecnych w artykule:

\begin{enumerate}
    \item Wyznaczenie zbioru dominującego spójnego. Problem ten również jest NP-trudny, dlatego zbiór ten wyznaczono przy użyciu programowania liniowego, w celu zachowania poprawności rozwiązania oraz - dla wielu przypadków - w rozsądnym czasie. Ten fragment algorytmu zaimplementowano również na podstawie literatury \cite{CDS}.\\ 

        Należy zdefiniować funkcję celu jako minimalizację liczby wierzchołków w zbiorze dominującym:
        \[
        Z: \min \sum_{v \in V} x_v
        \]

        Należy zdefiniować następujące zmienne decyzyjne:
        \[
        x_v =
        \begin{cases}
        1, & \text{jeśli } v \in \text{CDS} \\
        0, & \text{jeśli } v \notin \text{CDS}
        \end{cases}
        \]
        oraz \( f_{uv} \in {Z}_{\geq 0} \) - ilość jednostek przepływu z \( u \) do \( v \), dla każdej krawędzi \( (u, v) \in E \)

        Ograniczenia:

        Dominowanie - każdy wierzchołek musi być zdominowany przez samego siebie lub przez sąsiada:
        \[
        \forall v \in V:\quad x_v + \sum_{u \in N(v)} x_u \geq 1, \tag{1}
        \]

        Bilans przepływu dla każdego wierzchołka \( v \neq r \):
        \[
        \forall v \in V \setminus \{r\}:\quad \sum_{u \in N(v)} f_{uv} - \sum_{u \in N(v)} f_{vu} = x_v, \tag{2}
        \]

        Źródło przepływu - wysyła dokładnie \( \sum x_v - 1 \) jednostek przepływu:
        \[
        \sum_{u \in N(r)} f_{ru} = \sum_{v \in V} x_v - 1, \tag{3}
        \]

        Ograniczenie przepływu - przepływ możliwy tylko między wierzchołkami należącymi do CDS:
        \[
        \forall (u, v) \in E:\quad f_{uv} \leq (|V| - 1) \cdot x_u \quad \text{oraz} \quad f_{uv} \leq (|V| - 1) \cdot x_v, \tag{4}
        \]
    \item Dla wierzchołków CDS przypisywana jest wartość 2, dla pozostałych wierzchołków przypisywana jest wartość 0.
\end{enumerate}

\subsection{Poprawność}

Poniżej przedstawiona zostanie analiza poprawności algorytmu Approx. Algorytm opiera się na wyznaczeniu CDS przy pomocy programowania liniowego, a następnie przypisaniu wszystkim wierzchołkom należącym do tego zbioru wartości \( f(v) = 2 \), a pozostałym \( f(v) = 0 \). Wystarczy zatem wykazać, że model wyznacza spójny zbiór dominujący, a takie przypisanie będzie spełniało definicję WCRDF z niekoniecznie optymalną sumą wag.\\
\textbf{Poprawność modelu ILP wyznaczającego CDS}

Model zawiera zmienne binarne \( x_v \) określające, czy wierzchołek \( v \in V \) należy do zbioru dominującego. Warunki modelu:

\begin{itemize}
    \item Dominowanie: dla każdego wierzchołka \( v \in V \), zachodzi:
    \[
    x_v + \sum_{u \in N(v)} x_u \geq 1
    \]
    co gwarantuje, że każdy wierzchołek jest albo w CDS, albo sąsiaduje z wierzchołkiem z CDS.

    \item Spójność: warunki przepływu zapewniają, że zbiór \( \{v : x_v = 1\} \) tworzy spójny podgraf:
    \begin{itemize}
        \item Jedno źródło  \( r \) wysyła \( \sum x_v - 1 \) jednostek przepływu.
        \item Każdy inny wierzchołek w CDS musi otrzymać dokładnie jedną jednostkę.
        \item Przepływ \( f_{uv} \) jest dozwolony tylko wtedy, gdy \( x_u = 1 \) i \( x_v = 1 \).
    \end{itemize}
    Taka konstrukcja odpowiada przesyłaniu przepływu po drzewie rozpinającym na CDS, co zapewnia jego spójność.
\end{itemize}

\subsection{Złożoność i wydajność}

W pesymistycznym przypadku złożoność czasowa modelu programowania liniowego jest wykładnicza, bo należy przeszukać całą przestrzeń binarną. Model zawiera $n$ zmiennych $x_v$ oraz $2m$ zmiennych przepływu $f_{uv}$. Dodatkowo zawiera $n + 2m$ ograniczeń. Zatem liczba zmiennych oraz ograniczeń wynosi $O(n+m)$. Złożoność pamięciowa to również $O(n+m)$. 

\subsection{Pseudokod}
\begin{algorithm}[H]
    \caption*{Algorytm aproksymacyjny}
    \begin{algorithmic}[1]
        \Function{ComputeDominatingSet}{$G$}
        \State $N \gets$ list of nodes in $G$
        \State $E \gets$ list of edges in $G$
        \State $x_v \in \{0,1\}$ for all $v \in N$
        \State Choose arbitrary root $r \in N$
        \State $f_{uv} \in {Z}_{\geq 0}$ for all $(u,v) \in E$ and reversed
    
        \State Minimize $\sum_{v \in N} x_v$
        \ForAll{$v \in N$}
            \State Ensure: $x_v + \sum_{u \in \text{Neighbors}(v)} x_u \geq 1$ \Comment{Dominowanie}
        \EndFor
    
        \ForAll{$v \in N, v \neq r$}
            \State Inflow $\gets \sum_{u \in \text{Neighbors}(v)} f_{uv}$
            \State Outflow $\gets \sum_{u \in \text{Neighbors}(v)} f_{vu}$
            \State Ensure: Inflow $-$ Outflow $= x_v$ \Comment{Bilans przepływu}
        \EndFor
    
        \State Ensure: $\sum_{u \in \text{Neighbors}(r)} f_{ru} = \sum_{v \in N} x_v - 1$ \Comment{Źródło przepływu}
    
        \ForAll{$(u, v) \in E$ and $(v, u)$}
            \State Ensure: $f_{uv} \leq (|N|-1) \cdot x_u$
            \State Ensure: $f_{uv} \leq (|N|-1) \cdot x_v$ \Comment{Warunki spójności}
        \EndFor
    
        \State Solve
        \State \Return $\{v \in N : x_v = 1\}$
    \EndFunction
        \Function{Execute}{$G$}
        \State $N \gets$ list of nodes in $G$
        \State $D \gets$ \Call{ComputeDominatingSet}{$G$}
        \ForAll{$v \in N$}
            \If{$v \in D$}
                \State $value[v] \gets 2$
            \Else
                \State $value[v] \gets 0$
            \EndIf
        \EndFor
        \State $R \gets \sum_{v \in N} value[v]$
        \State \Return $(R, value)$
    \EndFunction
    \end{algorithmic}
    \end{algorithm}

    \section{Algorytm zachłanny}

    Poprawny algorytm zachłanny dla tego problemu nie został znaleziony wśród istniejących rozwiązań, dlatego został on opracowany i zaimplementowany w ramach tej pracy. 

    \subsection{Działanie}
    
    \begin{enumerate}
        \item Początkowo należy zdefiniować zbiory wierzchołków chronionych (początkowo pusty) i niechronionych (początkowo wszystkie wierzchołki grafu). Wierzchołki chronione to takie, które dominują same siebie, bądź takie, których sąsiad jest dominujący, niechronione to to takie, które nie należą do zbioru dominującego, ich sąsiedzi również.
        \item Wybierany jest wierzchołek o największym stopniu, jako wierzchołek startowy. Przypisywana mu jest wartość 2, a następnie jest on dodawany do zbioru wierzchołków chronionych, usuwając go z niechronionych. Analogiczne postępowanie jest z sąsiadami tego wierzchołka, tj. usunięcie ich ze zbioru wierzchołków niechronionych, dodając do chronionych. 
        \item Następnie, dopóki istnieją wierzchołki w zbiorze wierzchołków niechronionych:
        \begin{itemize}
            \item Iteracja po zbiorze wierzchołków chronionych, wyznaczając ich sąsiadów. Jeśli znajdzie się wierzchołek niechroniony, jest on dodawany do zbioru wierzchołków ,,kandydujących''.
            \item Jeśli zbiór ,,kandydatów'' jest pusty, pętla jest przerywana,
            \item W przypadku znalezienia ,,kandydatów'', wybierany jest wierzchołek, który zabezpieczy jak najwięcej wierzchołków jeszcze niechronionych.
            \item Następnie wykonywane jest sprawdzenie, czy będą istnieć nowo-ochronieni sąsiedzi. Jeśli nie, to nie ma potrzeby ustawiać temu wierzchołkowi wartości 2, przypisywana jest mu wartość 1. Jeśli istnieją tacy sąsiedzi, to przypisywana jest temu wierzchołkowi wartość 2. 
        \end{itemize}
    \end{enumerate}

    \subsection{Poprawność}

    Algorytm działa dla grafów spójnych i nie gwarantuje rozwiązania optymalnego, natomiast zapewnia, że zwracane jest WCRDF zgodne z definicją. Analiza poprawności opiera się na dwóch kluczowych własnościach.\\
    \textbf{Warunek dominowania rzymskiego}\\
    Algorytm rozpoczyna od przypisania wartości 2 wierzchołkowi o największym stopniu oraz zabezpieczenia jego sąsiadów. Następnie, dopóki istnieją wierzchołki niechronione (czyli z przypisaną wartością 0), wybierany jest wierzchołek $v$, który dominuje jak największą liczbę sąsiadów.\\
    W każdej iteracji:
    \begin{itemize}
        \item Jeśli $v$ zabezpiecza nowych sąsiadów, otrzymuje wartość $f(v) = 2$,
        \item Jeśli nie zabezpiecza nowych wierzchołków, ale należy do zbioru dominującego, otrzymuje $f(v) = 1$,
        \item Po każdej takiej decyzji zabezpieczani są również jego sąsiedzi.
    \end{itemize}

    W ten sposób każdy wierzchołek z wartością $f(v) = 0$ musi być sąsiadem jakiegoś wierzchołka z $f = 2$, ponieważ algorytm nie zatrzymuje się, dopóki zbiór niechronionych wierzchołków nie jest pusty.\\
    \textbf{Warunek słabej spójności}\\
    Zbiór $D = \{v \in V : f(v) \in \{1,2\} \}$ jest budowany iteracyjnie. W każdej iteracji dodawany jest do niego wierzchołek $v$, który jest sąsiadem jakiegoś wcześniej dodanego wierzchołka, wybranego ze zbioru ,,kandydatów".
    Zatem:
    \begin{itemize}
        \item pierwszy wierzchołek startowy tworzy początek spójnego zbioru $D$,
        \item każdy kolejny dodany wierzchołek jest połączony z wcześniejszym,
        \item czyli zbiór $D$ rozszerza się w sposób, który zapewnia spójność grafu słabo indukowanego przez $D$.
    \end{itemize}
    Zatem algorytm zapewnia, że zwracane jest WCRDF zgodne z definicją.

    \subsection{Złożoność i wydajność}

    Inicjacja wszystkich zmiennych wykonuje się w czasie liniowym. Iteracyjna ochrona wszystkich wierzchołków w najgorszym przypadku może wynieść $O(n)$, bo każda iteracja zabezpiecza przynajmniej jeden wierzchołek. Dodatkowo należy dokonać iteracji przez niezabezpieczone jeszcze wierzchołki w maksymalnie $O(n)$ oraz ich sąsiadów, czyli w najgorszym wypadku po wszystkich krawędziach grafu - $O(m)$. Dodatkowe aktualizacje w głównej pętli wykonują się w czasie maksymalnie liniowym. Dlatego ostatecznie złożoność obliczeniowa wynosi $O(n(m+n))$. Zakładając, że dla grafów rzadkich $m=O(n)$, a dla grafów gęstych $m=O(n^2)$, to złożoność czasowa wynosi odpowiednio $O(n^2)$ oraz $O(n^3)$.\\
    Złożoność pamięciowa obejmuje struktury danych przechowujące graf wejściowy, dlatego wynosi ona $O(n+m)$.\\
    Algorytm nie jest dokładny, natomiast w stosunku do innych proponowanych algorytmów, charakteryzuje się wielomianową złożonością obliczeniową.
    
    \subsection{Pseudokod}

    \begin{algorithm}
    \caption*{Algorytm zachłanny}
    \begin{algorithmic}[1]
        \Function{Execute}{$G$}
        \State $f[v] \gets 0$ for all $v \in$ nodes of $G$
        \State $secured\_nodes \gets \emptyset$
        \State $uncovered\_nodes \gets$ set of all nodes in $G$

        \State $start\_node \gets$ node with maximum degree
        \State $f[start\_node] \gets 2$
        \State Add $start\_node$ to $secured\_nodes$
        \State Remove $start\_node$ from $uncovered\_nodes$
        
        \ForAll{neighbors $neighbor$ of $start\_node$}
            \State Add $neighbor$ to $secured\_nodes$
            \State Remove $neighbor$ from $uncovered\_nodes$
        \EndFor

        \While{$uncovered\_nodes$ is not empty}
            \State $candidate\_nodes \gets \emptyset$
            \ForAll{$v \in secured\_nodes$}
                \ForAll{neighbors $neighbor$ of $v$}
                    \If{$neighbor \in uncovered\_nodes$}
                        \State Add $neighbor$ to $candidate\_nodes$
                    \EndIf
                \EndFor
            \EndFor

            \If{$candidate\_nodes$ is empty}
                \State \textbf{break}
            \EndIf

            \State $node \gets$ node in $candidate\_nodes$ covering the most uncovered neighbors
            \State $new\_covered\_neighbors \gets$ number of uncovered neighbors of $node$

            \If{$new\_covered\_neighbors > 0$}
                \State $f[node] \gets 2$
            \Else
                \State $f[node] \gets 1$
            \EndIf

            \State Add $node$ to $secured\_nodes$
            \State Remove $node$ from $uncovered\_nodes$
            \ForAll{neighbors $neighbor$ of $node$}
                \State Add $neighbor$ to $secured\_nodes$
                \State Remove $neighbor$ from $uncovered\_nodes$
            \EndFor
        \EndWhile

        \State $min\_roman\_domiantion\_number \gets \sum_{v} f[v]$
        \State \Return $(min\_roman\_domiantion\_number, f)$
        \EndFunction
    \end{algorithmic}
\end{algorithm}
