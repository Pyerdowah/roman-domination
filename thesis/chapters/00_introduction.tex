\chapter{Wstęp i cel pracy}
Tematem pracy jest analiza algorytmów znajdujących funkcje dominujące rzymskie słabo spójne w grafach.
Problem znajdowania liczby dominowania rzymskiego słabo spójnego jest problemem NP-trudnym. Nie są znane zatem dokładne algorytmy rozwiązujące i weryfikujące problem w czasie wielomianowym. Wersja decyzyjna tego problemu, czyli znalezienie funkcji dominowania rzymskiego słabo spójnego, jest NP-zupełna. Dodatkową motywacją jest widoczny potencjał zastosowania tego dominowania w rozwiązywaniu praktycznych problemów. Dlatego niniejsza praca dokonuje analizy istniejących w literaturze i proponowanych algorytmów znajdowania liczby dominowania rzymskiego słabo spójnego, jak i funkcji dominowania rzymskiego słabo spójnego, w celu znalezienia możliwie skutecznych rozwiązań oraz zastosowań. Całe rozważania dotyczą grafów spójnych.

\section{Cel pracy}
Celem badawczym pracy jest opisanie istniejących i opracowanie własnych algorytmów znajdujących funkcje dominujące rzymskie słabo spójne, ich analiza oraz porównanie skuteczności i wyciągnięcie wniosków na temat możliwości ich praktycznego zastosowania.

\section{Zakres pracy}
W ramach pracy dokonano systematycznego przeglądu literatury. W literaturze szczegółowo zdefiniowano ten problem oraz zbadano jego złożoność obliczeniową. Zaproponowano również kilka algorytmów rozwiązujących ten problem - znajdujacych liczbę dominowania rzymskiego słabo spójnego - wykorzystujących m.in. programowanie liniowe - jak i znajdujących funkcję dominowania rzymskiego słabo spójnego (niekoniecznie najmniejszą liczbę dominowania rzymskiego słabo spójnego). Na podstawie znalezionej literatury zaimplementowane zostały dwa algorytmy programowania liniowego oraz algorytm $2(1+\epsilon)(1 + \ln(\Delta - 1))$-aproksymacyjny. W ramach własnej pracy, zaimplementowano algorytm brute force, zachłanny oraz mrówkowy. Wraz z promotorką udało się opracować i zaimplementować dodatkowo algorytm liniowy dla drzew. Niniejsza praca przedstawia problem dominowania rzymskiego słabo spójnego oraz jego złożoność obliczeniową. Opisuje wymienione algorytmy, porównuje je pod kątem wydajności, poprawności oraz czasu działania. Testy przeprowadzono na różnych klasach grafów: gęstych, rzadkich, drzewach oraz bezskalowych. Następnie dokonano analizy potencjalnych praktycznych zastosowań, w których algorytmiczne rozwiązanie tego problemu byłoby przydatne. Na koniec dokonano podsumowania wszystkich wyników dotyczących przeprowadzonych rozważań.